{"version":3,"file":"drag-drop-polyfill-scroll-behaviour.js","sourceRoot":"","sources":["drag-drop-polyfill-scroll-behaviour.ts"],"names":[],"mappings":"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","sourcesContent":["import { DragDropPolyfill as polyfill, Point, DragImageTranslateOverrideFn, Config } from './drag-drop-polyfill.js';\n\nlet _options:ScrollOptions = {\n    threshold: 75,\n    // simplified cubic-ease-in function\n    velocityFn: function( velocity:number, threshold:number ) {\n        const multiplier = velocity / threshold;\n        const easeInCubic = multiplier * multiplier * multiplier;\n        return easeInCubic * threshold;\n    }\n};\n\nlet _scrollIntentions:ScrollIntentions = {\n    horizontal: ScrollIntention.NONE,\n    vertical: ScrollIntention.NONE\n};\n\nlet _dynamicVelocity:Point = {\n    x: 0,\n    y: 0\n};\n\nlet _scrollAnimationFrameId:any;\nlet _currentCoordinates:Point;\nlet _hoveredElement:HTMLElement;\nlet _scrollableParent:HTMLElement;\nlet _translateDragImageFn:( offsetX:number, offsetY:number ) => void;\n\n/**\n * core handler function\n */\nfunction handleDragImageTranslateOverride( event:TouchEvent,\n                                           currentCoordinates:Point,\n                                           hoveredElement:HTMLElement,\n                                           translateDragImageFn:( scrollDiffX:number, scrollDiffY:number ) => void ):void {\n\n    _currentCoordinates = currentCoordinates;\n    _translateDragImageFn = translateDragImageFn;\n\n    // update parent if hovered element changed\n    if( _hoveredElement !== hoveredElement ) {\n\n        _hoveredElement = hoveredElement;\n        _scrollableParent = findScrollableParent( _hoveredElement );\n    }\n\n    // update scroll intention and check if we should scroll at all\n    //TODO implement scroll chaining? if scroll end is reached continue to look for scrollable parent\n    const performScrollAnimation = updateScrollIntentions( _currentCoordinates, _scrollableParent, _options.threshold, _scrollIntentions, _dynamicVelocity );\n\n    // no animation in progress but scroll is intended\n    if( performScrollAnimation ) {\n\n        // setup scroll animation frame\n        scheduleScrollAnimation();\n    }\n    else if( !!_scrollAnimationFrameId ) {\n\n        window.cancelAnimationFrame( _scrollAnimationFrameId );\n        _scrollAnimationFrameId = null;\n    }\n}\n\n//<editor-fold desc=\"programmatic scroll animation frame handler\">\n\nfunction scheduleScrollAnimation() {\n\n    // prevent scheduling when already scheduled\n    if( !!_scrollAnimationFrameId ) {\n\n        return;\n    }\n\n    _scrollAnimationFrameId = window.requestAnimationFrame( scrollAnimation );\n}\n\nfunction scrollAnimation() {\n\n    let scrollDiffX = 0,\n        scrollDiffY = 0,\n        isTopLevel  = isTopLevelEl( _scrollableParent );\n\n    if( _scrollIntentions.horizontal !== ScrollIntention.NONE ) {\n\n        scrollDiffX = Math.round( _options.velocityFn( _dynamicVelocity.x, _options.threshold ) * _scrollIntentions.horizontal );\n        getSetElementScroll( _scrollableParent, ScrollAxis.HORIZONTAL, scrollDiffX );\n    }\n\n    if( _scrollIntentions.vertical !== ScrollIntention.NONE ) {\n\n        scrollDiffY = Math.round( _options.velocityFn( _dynamicVelocity.y, _options.threshold ) * _scrollIntentions.vertical );\n        getSetElementScroll( _scrollableParent, ScrollAxis.VERTICAL, scrollDiffY );\n    }\n\n    if( isTopLevel ) {\n        // on top level element scrolling we need to translate the drag image as much as we scroll\n        _translateDragImageFn( scrollDiffX, scrollDiffY );\n    }\n    else {\n        // just scroll the container and update the drag image position without offset\n        _translateDragImageFn( 0, 0 );\n    }\n\n    // reset to make sure we can re-schedule scroll animation\n    _scrollAnimationFrameId = null;\n\n    // check if we should continue scrolling\n    //TODO implement scroll chaining? if scroll end is reached continue to look for scrollable parent\n    if( updateScrollIntentions( _currentCoordinates, _scrollableParent, _options.threshold, _scrollIntentions, _dynamicVelocity ) ) {\n\n        // re-schedule animation frame callback\n        scheduleScrollAnimation();\n    }\n}\n\n//</editor-fold>\n\n//<editor-fold desc=\"scroll checks\">\n\nfunction updateScrollIntentions( currentCoordinates:Point,\n                                 scrollableParent:HTMLElement,\n                                 threshold:number,\n                                 scrollIntentions:ScrollIntentions,\n                                 dynamicVelocity:Point ):boolean {\n\n    if( !currentCoordinates || !scrollableParent ) {\n\n        // when coordinates become undefined drag operation stopped. stop scrolling also.\n        return false;\n    }\n\n    const scrollableParentBounds:IScrollBounds = {\n        x: getElementViewportOffset( scrollableParent, ScrollAxis.HORIZONTAL ),\n        y: getElementViewportOffset( scrollableParent, ScrollAxis.VERTICAL ),\n        width: getElementViewportSize( scrollableParent, ScrollAxis.HORIZONTAL ),\n        height: getElementViewportSize( scrollableParent, ScrollAxis.VERTICAL ),\n        scrollX: getSetElementScroll( scrollableParent, ScrollAxis.HORIZONTAL ),\n        scrollY: getSetElementScroll( scrollableParent, ScrollAxis.VERTICAL ),\n        scrollWidth: scrollableParent.scrollWidth,\n        scrollHeight: scrollableParent.scrollHeight\n    };\n\n    const currentCoordinatesOffset = {\n        x: currentCoordinates.x - scrollableParentBounds.x,\n        y: currentCoordinates.y - scrollableParentBounds.y\n    };\n\n    scrollIntentions.horizontal = determineScrollIntention( currentCoordinatesOffset.x, scrollableParentBounds.width, threshold );\n    scrollIntentions.vertical = determineScrollIntention( currentCoordinatesOffset.y, scrollableParentBounds.height, threshold );\n\n    if( scrollIntentions.horizontal && isScrollEndReached( ScrollAxis.HORIZONTAL, scrollIntentions.horizontal, scrollableParentBounds ) ) {\n\n        // if scroll end is reached, reset to none\n        scrollIntentions.horizontal = ScrollIntention.NONE;\n    }\n    else if( scrollIntentions.horizontal ) {\n\n        dynamicVelocity.x = determineDynamicVelocity( scrollIntentions.horizontal, currentCoordinatesOffset.x, scrollableParentBounds.width, threshold );\n    }\n\n    if( scrollIntentions.vertical && isScrollEndReached( ScrollAxis.VERTICAL, scrollIntentions.vertical, scrollableParentBounds ) ) {\n\n        // if scroll end is reached, reset to none\n        scrollIntentions.vertical = ScrollIntention.NONE;\n    }\n    else if( scrollIntentions.vertical ) {\n\n        dynamicVelocity.y = determineDynamicVelocity( scrollIntentions.vertical, currentCoordinatesOffset.y, scrollableParentBounds.height, threshold );\n    }\n\n    return !!(scrollIntentions.horizontal || scrollIntentions.vertical);\n}\n\n//</editor-fold>\n\n//<editor-fold desc=\"static scroll utils\">\n\ninterface ScrollIntentions {\n    horizontal:ScrollIntention;\n    vertical:ScrollIntention;\n}\n\ninterface IScrollBounds {\n    x:number;\n    y:number;\n    width:number;\n    height:number;\n    scrollX:number;\n    scrollY:number;\n    scrollHeight:number;\n    scrollWidth:number;\n}\n\nconst enum ScrollIntention {\n    NONE            = 0,\n    LEFT_OR_TOP     = -1,\n    RIGHT_OR_BOTTOM = 1\n}\n\nconst enum ScrollAxis {\n    HORIZONTAL,\n    VERTICAL\n}\n\nfunction isTopLevelEl( el:HTMLElement ):boolean {\n\n    return (el === document.body || el === document.documentElement);\n}\n\nfunction getElementViewportOffset( el:HTMLElement, axis:ScrollAxis ) {\n    let offset:number;\n\n    if( isTopLevelEl( el ) ) {\n        offset = (axis === ScrollAxis.HORIZONTAL) ? el.clientLeft : el.clientTop;\n    }\n    else {\n        const bounds = el.getBoundingClientRect();\n        offset = (axis === ScrollAxis.HORIZONTAL) ? bounds.left : bounds.top;\n    }\n\n    return offset;\n}\n\nfunction getElementViewportSize( el:HTMLElement, axis:ScrollAxis ) {\n    let size:number;\n\n    if( isTopLevelEl( el ) ) {\n        size = (axis === ScrollAxis.HORIZONTAL) ? window.innerWidth : window.innerHeight;\n    }\n    else {\n        size = (axis === ScrollAxis.HORIZONTAL) ? el.clientWidth : el.clientHeight;\n    }\n\n    return size;\n}\n\nfunction getSetElementScroll( el:HTMLElement, axis:ScrollAxis, scroll?:number ) {\n    const prop = (axis === ScrollAxis.HORIZONTAL) ? \"scrollLeft\" : \"scrollTop\";\n\n    // abstracting away compatibility issues on scroll properties of document/body\n    const isTopLevel = isTopLevelEl( el );\n\n    if( arguments.length === 2 ) {\n\n        if( isTopLevel ) {\n            return document.body[ prop ] || document.documentElement[ prop ];\n        }\n\n        return el[ prop ];\n    }\n\n    if( isTopLevel ) {\n        document.documentElement[ prop ] += scroll;\n        document.body[ prop ] += scroll;\n    }\n    else {\n        el[ prop ] += scroll;\n    }\n}\n\n//TODO check if scroll end is reached according to scroll intention? this is needed to implement scroll chaining\nfunction isScrollable( el:HTMLElement ):boolean {\n    const cs = getComputedStyle( el );\n\n    if( el.scrollHeight > el.clientHeight && (cs.overflowY === \"scroll\" || cs.overflowY === \"auto\") ) {\n        return true;\n    }\n\n    if( el.scrollWidth > el.clientWidth && (cs.overflowX === \"scroll\" || cs.overflowX === \"auto\") ) {\n        return true;\n    }\n\n    return false;\n}\n\nfunction findScrollableParent( el:HTMLElement ):HTMLElement {\n    do {\n        if( !el ) {\n            return undefined;\n        }\n        if( isScrollable( el ) ) {\n            return el;\n        }\n        if( el === document.documentElement ) {\n            return null;\n        }\n    } while( el = <HTMLElement>el.parentNode );\n    return null;\n}\n\nfunction determineScrollIntention( currentCoordinate:number, size:number, threshold:number ):ScrollIntention {\n\n    // LEFT / TOP\n    if( currentCoordinate < threshold ) {\n        return ScrollIntention.LEFT_OR_TOP;\n    }\n    // RIGHT / BOTTOM\n    else if( size - currentCoordinate < threshold ) {\n        return ScrollIntention.RIGHT_OR_BOTTOM;\n    }\n    // NONE\n    return ScrollIntention.NONE;\n}\n\nfunction determineDynamicVelocity( scrollIntention:ScrollIntention, currentCoordinate:number, size:number, threshold:number ):number {\n\n    if( scrollIntention === ScrollIntention.LEFT_OR_TOP ) {\n\n        return Math.abs( currentCoordinate - threshold );\n    }\n    else if( scrollIntention === ScrollIntention.RIGHT_OR_BOTTOM ) {\n\n        return Math.abs( size - currentCoordinate - threshold );\n    }\n\n    return 0;\n}\n\nfunction isScrollEndReached( axis:ScrollAxis, scrollIntention:ScrollIntention, scrollBounds:IScrollBounds ) {\n\n    const currentScrollOffset = (axis === ScrollAxis.HORIZONTAL) ? (scrollBounds.scrollX) : (scrollBounds.scrollY);\n\n    // wants to scroll to the right/bottom\n    if( scrollIntention === ScrollIntention.RIGHT_OR_BOTTOM ) {\n\n        const maxScrollOffset = (axis === ScrollAxis.HORIZONTAL) ? ( scrollBounds.scrollWidth - scrollBounds.width ) : ( scrollBounds.scrollHeight -\n                                                                                                                         scrollBounds.height );\n\n        // is already at the right/bottom edge\n        return currentScrollOffset >= maxScrollOffset;\n    }\n    // wants to scroll to the left/top\n    else if( scrollIntention === ScrollIntention.LEFT_OR_TOP ) {\n\n        // is already at left/top edge\n        return (currentScrollOffset <= 0);\n    }\n    // no scroll\n    return true;\n}\n\n//</editor-fold>\n\n//<editor-fold desc=\"public api\">\n\nexport interface ScrollOptions {\n    // threshold in px. when distance between scrollable element edge and touch position is smaller start programmatic scroll.\n    // defaults to 75px\n    threshold?:number;\n    // function to customize the scroll velocity\n    // velocity param: distance to scrollable element edge\n    // threshold: the threshold used to determine when scrolling should start\n    // defaults to cubic-ease-in.\n    velocityFn:( velocity:number, threshold:number ) => number;\n}\n\nfunction SetOptions( options:ScrollOptions ):void {\n\n    // overwrite defaults with input options\n    Object.keys( options ).forEach( function( key ) {\n        _options[ key ] = options[ key ];\n    } );\n}\n\nexport const HandleDragImageTranslateOverride:DragImageTranslateOverrideFn = handleDragImageTranslateOverride;\n\n//</editor-fold>\n\n\nexport const DragDropPolyfill = {\n    DEBUG: polyfill.DEBUG,\n    Initialize: polyfill.Initialize,\n    SetOptions: SetOptions\n};\n"]}