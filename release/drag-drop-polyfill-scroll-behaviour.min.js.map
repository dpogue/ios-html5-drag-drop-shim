{"version":3,"sources":["drag-drop-polyfill-scroll-behaviour.ts"],"names":["handleDragImageTranslateOverride","event","currentCoordinates","hoveredElement","translateDragImageFn","_currentCoordinates","_translateDragImageFn","_hoveredElement","_scrollableParent","findScrollableParent","updateScrollIntentions","_options","threshold","_scrollIntentions","_dynamicVelocity","scheduleScrollAnimation","_scrollAnimationFrameId","window","cancelAnimationFrame","requestAnimationFrame","scrollAnimation","scrollDiffX","scrollDiffY","isTopLevel","isTopLevelEl","horizontal","Math","round","velocityFn","x","getSetElementScroll","vertical","y","scrollableParent","scrollIntentions","dynamicVelocity","scrollableParentBounds","getElementViewportOffset","width","getElementViewportSize","height","scrollX","scrollY","scrollWidth","scrollHeight","currentCoordinatesOffset","determineScrollIntention","isScrollEndReached","determineDynamicVelocity","el","document","body","documentElement","axis","offset","clientLeft","clientTop","bounds","getBoundingClientRect","left","top","innerWidth","innerHeight","clientWidth","clientHeight","scroll","prop","arguments","length","isScrollable","cs","getComputedStyle","overflowY","overflowX","parentNode","currentCoordinate","size","scrollIntention","abs","scrollBounds","currentScrollOffset","SetOptions","options","Object","keys","forEach","key","drag_drop_polyfill_js_1","require","velocity","multiplier","exports","HandleDragImageTranslateOverride","DragDropPolyfill","DEBUG","Initialize"],"mappings":"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","file":"drag-drop-polyfill-scroll-behaviour.min.js","sourcesContent":["import { DragDropPolyfill as polyfill, Point, DragImageTranslateOverrideFn, Config } from './drag-drop-polyfill.js';\n\nlet _options:ScrollOptions = {\n    threshold: 75,\n    // simplified cubic-ease-in function\n    velocityFn: function( velocity:number, threshold:number ) {\n        const multiplier = velocity / threshold;\n        const easeInCubic = multiplier * multiplier * multiplier;\n        return easeInCubic * threshold;\n    }\n};\n\nlet _scrollIntentions:ScrollIntentions = {\n    horizontal: ScrollIntention.NONE,\n    vertical: ScrollIntention.NONE\n};\n\nlet _dynamicVelocity:Point = {\n    x: 0,\n    y: 0\n};\n\nlet _scrollAnimationFrameId:any;\nlet _currentCoordinates:Point;\nlet _hoveredElement:HTMLElement;\nlet _scrollableParent:HTMLElement;\nlet _translateDragImageFn:( offsetX:number, offsetY:number ) => void;\n\n/**\n * core handler function\n */\nfunction handleDragImageTranslateOverride( event:TouchEvent,\n                                           currentCoordinates:Point,\n                                           hoveredElement:HTMLElement,\n                                           translateDragImageFn:( scrollDiffX:number, scrollDiffY:number ) => void ):void {\n\n    _currentCoordinates = currentCoordinates;\n    _translateDragImageFn = translateDragImageFn;\n\n    // update parent if hovered element changed\n    if( _hoveredElement !== hoveredElement ) {\n\n        _hoveredElement = hoveredElement;\n        _scrollableParent = findScrollableParent( _hoveredElement );\n    }\n\n    // update scroll intention and check if we should scroll at all\n    //TODO implement scroll chaining? if scroll end is reached continue to look for scrollable parent\n    const performScrollAnimation = updateScrollIntentions( _currentCoordinates, _scrollableParent, _options.threshold, _scrollIntentions, _dynamicVelocity );\n\n    // no animation in progress but scroll is intended\n    if( performScrollAnimation ) {\n\n        // setup scroll animation frame\n        scheduleScrollAnimation();\n    }\n    else if( !!_scrollAnimationFrameId ) {\n\n        window.cancelAnimationFrame( _scrollAnimationFrameId );\n        _scrollAnimationFrameId = null;\n    }\n}\n\n//<editor-fold desc=\"programmatic scroll animation frame handler\">\n\nfunction scheduleScrollAnimation() {\n\n    // prevent scheduling when already scheduled\n    if( !!_scrollAnimationFrameId ) {\n\n        return;\n    }\n\n    _scrollAnimationFrameId = window.requestAnimationFrame( scrollAnimation );\n}\n\nfunction scrollAnimation() {\n\n    let scrollDiffX = 0,\n        scrollDiffY = 0,\n        isTopLevel  = isTopLevelEl( _scrollableParent );\n\n    if( _scrollIntentions.horizontal !== ScrollIntention.NONE ) {\n\n        scrollDiffX = Math.round( _options.velocityFn( _dynamicVelocity.x, _options.threshold ) * _scrollIntentions.horizontal );\n        getSetElementScroll( _scrollableParent, ScrollAxis.HORIZONTAL, scrollDiffX );\n    }\n\n    if( _scrollIntentions.vertical !== ScrollIntention.NONE ) {\n\n        scrollDiffY = Math.round( _options.velocityFn( _dynamicVelocity.y, _options.threshold ) * _scrollIntentions.vertical );\n        getSetElementScroll( _scrollableParent, ScrollAxis.VERTICAL, scrollDiffY );\n    }\n\n    if( isTopLevel ) {\n        // on top level element scrolling we need to translate the drag image as much as we scroll\n        _translateDragImageFn( scrollDiffX, scrollDiffY );\n    }\n    else {\n        // just scroll the container and update the drag image position without offset\n        _translateDragImageFn( 0, 0 );\n    }\n\n    // reset to make sure we can re-schedule scroll animation\n    _scrollAnimationFrameId = null;\n\n    // check if we should continue scrolling\n    //TODO implement scroll chaining? if scroll end is reached continue to look for scrollable parent\n    if( updateScrollIntentions( _currentCoordinates, _scrollableParent, _options.threshold, _scrollIntentions, _dynamicVelocity ) ) {\n\n        // re-schedule animation frame callback\n        scheduleScrollAnimation();\n    }\n}\n\n//</editor-fold>\n\n//<editor-fold desc=\"scroll checks\">\n\nfunction updateScrollIntentions( currentCoordinates:Point,\n                                 scrollableParent:HTMLElement,\n                                 threshold:number,\n                                 scrollIntentions:ScrollIntentions,\n                                 dynamicVelocity:Point ):boolean {\n\n    if( !currentCoordinates || !scrollableParent ) {\n\n        // when coordinates become undefined drag operation stopped. stop scrolling also.\n        return false;\n    }\n\n    const scrollableParentBounds:IScrollBounds = {\n        x: getElementViewportOffset( scrollableParent, ScrollAxis.HORIZONTAL ),\n        y: getElementViewportOffset( scrollableParent, ScrollAxis.VERTICAL ),\n        width: getElementViewportSize( scrollableParent, ScrollAxis.HORIZONTAL ),\n        height: getElementViewportSize( scrollableParent, ScrollAxis.VERTICAL ),\n        scrollX: getSetElementScroll( scrollableParent, ScrollAxis.HORIZONTAL ),\n        scrollY: getSetElementScroll( scrollableParent, ScrollAxis.VERTICAL ),\n        scrollWidth: scrollableParent.scrollWidth,\n        scrollHeight: scrollableParent.scrollHeight\n    };\n\n    const currentCoordinatesOffset = {\n        x: currentCoordinates.x - scrollableParentBounds.x,\n        y: currentCoordinates.y - scrollableParentBounds.y\n    };\n\n    scrollIntentions.horizontal = determineScrollIntention( currentCoordinatesOffset.x, scrollableParentBounds.width, threshold );\n    scrollIntentions.vertical = determineScrollIntention( currentCoordinatesOffset.y, scrollableParentBounds.height, threshold );\n\n    if( scrollIntentions.horizontal && isScrollEndReached( ScrollAxis.HORIZONTAL, scrollIntentions.horizontal, scrollableParentBounds ) ) {\n\n        // if scroll end is reached, reset to none\n        scrollIntentions.horizontal = ScrollIntention.NONE;\n    }\n    else if( scrollIntentions.horizontal ) {\n\n        dynamicVelocity.x = determineDynamicVelocity( scrollIntentions.horizontal, currentCoordinatesOffset.x, scrollableParentBounds.width, threshold );\n    }\n\n    if( scrollIntentions.vertical && isScrollEndReached( ScrollAxis.VERTICAL, scrollIntentions.vertical, scrollableParentBounds ) ) {\n\n        // if scroll end is reached, reset to none\n        scrollIntentions.vertical = ScrollIntention.NONE;\n    }\n    else if( scrollIntentions.vertical ) {\n\n        dynamicVelocity.y = determineDynamicVelocity( scrollIntentions.vertical, currentCoordinatesOffset.y, scrollableParentBounds.height, threshold );\n    }\n\n    return !!(scrollIntentions.horizontal || scrollIntentions.vertical);\n}\n\n//</editor-fold>\n\n//<editor-fold desc=\"static scroll utils\">\n\ninterface ScrollIntentions {\n    horizontal:ScrollIntention;\n    vertical:ScrollIntention;\n}\n\ninterface IScrollBounds {\n    x:number;\n    y:number;\n    width:number;\n    height:number;\n    scrollX:number;\n    scrollY:number;\n    scrollHeight:number;\n    scrollWidth:number;\n}\n\nconst enum ScrollIntention {\n    NONE            = 0,\n    LEFT_OR_TOP     = -1,\n    RIGHT_OR_BOTTOM = 1\n}\n\nconst enum ScrollAxis {\n    HORIZONTAL,\n    VERTICAL\n}\n\nfunction isTopLevelEl( el:HTMLElement ):boolean {\n\n    return (el === document.body || el === document.documentElement);\n}\n\nfunction getElementViewportOffset( el:HTMLElement, axis:ScrollAxis ) {\n    let offset:number;\n\n    if( isTopLevelEl( el ) ) {\n        offset = (axis === ScrollAxis.HORIZONTAL) ? el.clientLeft : el.clientTop;\n    }\n    else {\n        const bounds = el.getBoundingClientRect();\n        offset = (axis === ScrollAxis.HORIZONTAL) ? bounds.left : bounds.top;\n    }\n\n    return offset;\n}\n\nfunction getElementViewportSize( el:HTMLElement, axis:ScrollAxis ) {\n    let size:number;\n\n    if( isTopLevelEl( el ) ) {\n        size = (axis === ScrollAxis.HORIZONTAL) ? window.innerWidth : window.innerHeight;\n    }\n    else {\n        size = (axis === ScrollAxis.HORIZONTAL) ? el.clientWidth : el.clientHeight;\n    }\n\n    return size;\n}\n\nfunction getSetElementScroll( el:HTMLElement, axis:ScrollAxis, scroll?:number ) {\n    const prop = (axis === ScrollAxis.HORIZONTAL) ? \"scrollLeft\" : \"scrollTop\";\n\n    // abstracting away compatibility issues on scroll properties of document/body\n    const isTopLevel = isTopLevelEl( el );\n\n    if( arguments.length === 2 ) {\n\n        if( isTopLevel ) {\n            return document.body[ prop ] || document.documentElement[ prop ];\n        }\n\n        return el[ prop ];\n    }\n\n    if( isTopLevel ) {\n        document.documentElement[ prop ] += scroll;\n        document.body[ prop ] += scroll;\n    }\n    else {\n        el[ prop ] += scroll;\n    }\n}\n\n//TODO check if scroll end is reached according to scroll intention? this is needed to implement scroll chaining\nfunction isScrollable( el:HTMLElement ):boolean {\n    const cs = getComputedStyle( el );\n\n    if( el.scrollHeight > el.clientHeight && (cs.overflowY === \"scroll\" || cs.overflowY === \"auto\") ) {\n        return true;\n    }\n\n    if( el.scrollWidth > el.clientWidth && (cs.overflowX === \"scroll\" || cs.overflowX === \"auto\") ) {\n        return true;\n    }\n\n    return false;\n}\n\nfunction findScrollableParent( el:HTMLElement ):HTMLElement {\n    do {\n        if( !el ) {\n            return undefined;\n        }\n        if( isScrollable( el ) ) {\n            return el;\n        }\n        if( el === document.documentElement ) {\n            return null;\n        }\n    } while( el = <HTMLElement>el.parentNode );\n    return null;\n}\n\nfunction determineScrollIntention( currentCoordinate:number, size:number, threshold:number ):ScrollIntention {\n\n    // LEFT / TOP\n    if( currentCoordinate < threshold ) {\n        return ScrollIntention.LEFT_OR_TOP;\n    }\n    // RIGHT / BOTTOM\n    else if( size - currentCoordinate < threshold ) {\n        return ScrollIntention.RIGHT_OR_BOTTOM;\n    }\n    // NONE\n    return ScrollIntention.NONE;\n}\n\nfunction determineDynamicVelocity( scrollIntention:ScrollIntention, currentCoordinate:number, size:number, threshold:number ):number {\n\n    if( scrollIntention === ScrollIntention.LEFT_OR_TOP ) {\n\n        return Math.abs( currentCoordinate - threshold );\n    }\n    else if( scrollIntention === ScrollIntention.RIGHT_OR_BOTTOM ) {\n\n        return Math.abs( size - currentCoordinate - threshold );\n    }\n\n    return 0;\n}\n\nfunction isScrollEndReached( axis:ScrollAxis, scrollIntention:ScrollIntention, scrollBounds:IScrollBounds ) {\n\n    const currentScrollOffset = (axis === ScrollAxis.HORIZONTAL) ? (scrollBounds.scrollX) : (scrollBounds.scrollY);\n\n    // wants to scroll to the right/bottom\n    if( scrollIntention === ScrollIntention.RIGHT_OR_BOTTOM ) {\n\n        const maxScrollOffset = (axis === ScrollAxis.HORIZONTAL) ? ( scrollBounds.scrollWidth - scrollBounds.width ) : ( scrollBounds.scrollHeight -\n                                                                                                                         scrollBounds.height );\n\n        // is already at the right/bottom edge\n        return currentScrollOffset >= maxScrollOffset;\n    }\n    // wants to scroll to the left/top\n    else if( scrollIntention === ScrollIntention.LEFT_OR_TOP ) {\n\n        // is already at left/top edge\n        return (currentScrollOffset <= 0);\n    }\n    // no scroll\n    return true;\n}\n\n//</editor-fold>\n\n//<editor-fold desc=\"public api\">\n\nexport interface ScrollOptions {\n    // threshold in px. when distance between scrollable element edge and touch position is smaller start programmatic scroll.\n    // defaults to 75px\n    threshold?:number;\n    // function to customize the scroll velocity\n    // velocity param: distance to scrollable element edge\n    // threshold: the threshold used to determine when scrolling should start\n    // defaults to cubic-ease-in.\n    velocityFn:( velocity:number, threshold:number ) => number;\n}\n\nfunction SetOptions( options:ScrollOptions ):void {\n\n    // overwrite defaults with input options\n    Object.keys( options ).forEach( function( key ) {\n        _options[ key ] = options[ key ];\n    } );\n}\n\nexport const HandleDragImageTranslateOverride:DragImageTranslateOverrideFn = handleDragImageTranslateOverride;\n\n//</editor-fold>\n\n\nexport const DragDropPolyfill = {\n    DEBUG: polyfill.DEBUG,\n    Initialize: polyfill.Initialize,\n    SetOptions: SetOptions\n};\n"]}